# Лабораторная работа 03 - Рекурсия

**Дата:** 22.09.2025  
**Семестр:** 3 курс, 1 семестр  
**Группа:** ПИЖ-б-о-23-1-(1)
**Дисциплина:** Алгоритмы и структуры данных  
**Студент:** Алдабаева Виктория Владимировна  

## Описание проекта

Проект реализует различные хеш-функции и методы разрешения коллизий в хеш-таблицах. Проведен сравнительный анализ эффективности разных методов при различных коэффициентах заполнения.

## Цель работы

Изучить принципы работы хеш-функций и хеш-таблиц. Освоить методы разрешения коллизий. Получить практические навыки реализации хеш-таблицы с различными стратегиями разрешения коллизий. Провести сравнительный анализ эффективности разных методов.

## Теоретическая часть
- **Хеш-функция**: Функция, преобразующая произвольные данные в данные фиксированного размера (хеш-код)
- **Хеш-таблица**: Структура данных, реализующая ассоциативный массив с операциями O(1) в среднем случае
- **Коллизия**: Ситуация, когда разные ключи имеют одинаковый хеш-код
- **Метод цепочек**: Каждая ячейка таблицы содержит список элементов с одинаковым хешем
- **Открытая адресация**: Все элементы хранятся в самом массиве, при коллизии ищется следующая свободная ячейка
- **Двойное хеширование**: Метод открытой адресации, использующий вторую хеш-функцию для определения шага probing


## Практическая часть

### Выполненные задачи
- [x] Задача 1: Реализация 3 хеш-функций для строковых ключей
- [x] Задача 2: Реализация хеш-таблицы с методом цепочек
- [x] Задача 3: Реализация хеш-таблицы с открытой адресацией (линейное пробирование и двойное хеширование)
- [x] Задача 4: Сравнительный анализ эффективности разных методов разрешения коллизий
- [x] Задача 5: Исследование влияния коэффициента заполнения на производительность


### Ключевые фрагменты кода
```python
def polynomial_hash(key: str, table_size: int, base: int = 31) -> int:
    """
    Полиномиальная хеш-функция.
    
    Args:
        key: Строковый ключ
        table_size: Размер хеш-таблицы
        base: Основание полинома
        
    Returns:
        Хеш-значение в диапазоне [0, table_size-1]
    """
    hash_value = 0
    for char in key:
        hash_value = (hash_value * base + ord(char)) % table_size
    return hash_value

class HashTableChaining:
    """Хеш-таблица с методом цепочек для разрешения коллизий."""
    
    def insert(self, key: str, value: Any) -> None:
        """
        Вставка элемента в хеш-таблицу.
        
        Time Complexity: O(1) в среднем, O(n) в худшем случае
        """
        if self.load_factor > self.load_factor_threshold:
            self._resize(self.size * 2)
        
        index = self._hash(key)
        bucket = self.table[index]
        
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)
                return
        
        bucket.append((key, value))
        self.count += 1

class HashTableOpenAddressing:
    """Хеш-таблица с открытой адресацией."""
    
    def _hash(self, key: str, attempt: int = 0) -> int:
        """Вычисление хеша с учетом номера попытки."""
        if self.probing_method == 'linear':
            return (self.hash_func(key, self.size) + attempt) % self.size
        elif self.probing_method == 'double':
            h1 = self.hash_func(key, self.size)
            h2 = 1 + (self.hash_func(key, self.size - 1))
            return (h1 + attempt * h2) % self.size
  ```

  ### Результат выполнения

  ```bash
Запуск анализа производительности...
Size: 100, Load: 0.1, Impl: Chaining      
  Insert: 0.000000s, Search: 0.000000s    
  Collisions: 0
Size: 100, Load: 0.1, Impl: Linear Probing
  Insert: 0.000000s, Search: 0.000000s    
  Collisions: 0
Size: 100, Load: 0.1, Impl: Double Hashing
  Insert: 0.000000s, Search: 0.000000s    
  Collisions: 0
Size: 100, Load: 0.5, Impl: Chaining      
  Insert: 0.000000s, Search: 0.000000s    
  Collisions: 7
Size: 100, Load: 0.5, Impl: Linear Probing
  Insert: 0.000457s, Search: 0.000000s
  Collisions: 7
Size: 100, Load: 0.5, Impl: Double Hashing
  Insert: 0.000998s, Search: 0.000000s
  Collisions: 7
Size: 100, Load: 0.7, Impl: Chaining
  Insert: 0.000000s, Search: 0.000000s
  Collisions: 21
Size: 100, Load: 0.7, Impl: Linear Probing
  Insert: 0.000344s, Search: 0.000000s
  Collisions: 28
Size: 100, Load: 0.7, Impl: Double Hashing
  Insert: 0.000999s, Search: 0.000998s
  Collisions: 12
Size: 100, Load: 0.9, Impl: Chaining
  Insert: 0.000993s, Search: 0.000000s
  Collisions: 12
Size: 100, Load: 0.9, Impl: Linear Probing
  Insert: 0.006482s, Search: 0.000000s
  Collisions: 16
Size: 100, Load: 0.9, Impl: Double Hashing
  Insert: 0.015679s, Search: 0.000000s
  Collisions: 10
Size: 500, Load: 0.1, Impl: Chaining
  Insert: 0.000997s, Search: 0.000000s
  Collisions: 4
Size: 500, Load: 0.1, Impl: Linear Probing
  Insert: 0.000000s, Search: 0.000000s
  Collisions: 4
Size: 500, Load: 0.1, Impl: Double Hashing
  Insert: 0.000994s, Search: 0.000000s
  Collisions: 4
Size: 500, Load: 0.5, Impl: Chaining
  Insert: 0.002000s, Search: 0.001004s
  Collisions: 82
Size: 500, Load: 0.5, Impl: Linear Probing
  Insert: 0.031915s, Search: 0.025082s
  Collisions: 110
Size: 500, Load: 0.5, Impl: Double Hashing
  Insert: 0.002857s, Search: 0.001999s
  Collisions: 89
Size: 500, Load: 0.7, Impl: Chaining
  Insert: 0.001969s, Search: 0.000997s
  Collisions: 159
Size: 500, Load: 0.7, Impl: Linear Probing
  Insert: 0.131382s, Search: 0.081781s
  Collisions: 221
Size: 500, Load: 0.7, Impl: Double Hashing
  Insert: 0.007943s, Search: 0.008976s
  Collisions: 185
Size: 500, Load: 0.9, Impl: Chaining
  Insert: 0.005985s, Search: 0.002992s
  Collisions: 227
Size: 500, Load: 0.9, Impl: Linear Probing
  Insert: 0.219411s, Search: 0.110059s
  Collisions: 345
Size: 500, Load: 0.9, Impl: Double Hashing
  Insert: 0.019948s, Search: 0.011967s
  Collisions: 239
Size: 1000, Load: 0.1, Impl: Chaining
  Insert: 0.000998s, Search: 0.000997s
  Collisions: 21
Size: 1000, Load: 0.1, Impl: Linear Probing
  Insert: 0.000997s, Search: 0.000996s
  Collisions: 26
Size: 1000, Load: 0.1, Impl: Double Hashing
  Insert: 0.001996s, Search: 0.000997s
  Collisions: 22
Size: 1000, Load: 0.5, Impl: Chaining
  Insert: 0.002992s, Search: 0.003989s
  Collisions: 277
Size: 1000, Load: 0.5, Impl: Linear Probing
  Insert: 0.199620s, Search: 0.107558s
  Collisions: 363
Size: 1000, Load: 0.5, Impl: Double Hashing
  Insert: 0.021460s, Search: 0.004958s
  Collisions: 280
Size: 1000, Load: 0.7, Impl: Chaining
  Insert: 0.000997s, Search: 0.000997s
  Collisions: 442
Size: 1000, Load: 0.7, Impl: Linear Probing
  Insert: 0.271177s, Search: 0.331115s
  Collisions: 571
Size: 1000, Load: 0.7, Impl: Double Hashing
  Insert: 0.035904s, Search: 0.014963s
  Collisions: 447
Size: 1000, Load: 0.9, Impl: Chaining
  Insert: 0.009972s, Search: 0.004986s
  Collisions: 610
Size: 1000, Load: 0.9, Impl: Linear Probing
  Insert: 1.038105s, Search: 0.549530s
  Collisions: 732
Size: 1000, Load: 0.9, Impl: Double Hashing
  Insert: 0.048871s, Search: 0.015954s
  Collisions: 610
  ```

  ## Выводы
  1. Метод цепочек демонстрирует стабильную производительность даже при высоких коэффициентах заполнения (0.9). Время операций увеличивается плавно, что делает его надежным выбором для приложений с переменной нагрузкой.

  2. Открытая адресация с линейным пробированием показывает хорошую производительность при низких коэффициентах заполнения (<0.7), но значительно замедляется при высоких нагрузках из-за кластеризации.

  3. Двойное хеширование обеспечивает лучшее распределение элементов по сравнению с линейным пробированием, что снижает количество коллизий и улучшает производительность при высоких коэффициентах заполнения.

  4. Влияние коэффициента заполнения существенно для всех методов, но наиболее критично для открытой адресации. Рекомендуется поддерживать коэффициент заполнения ≤0.7 для открытой адресации и ≤0.9 для метода цепочек.

  5. Сравнение хеш-функций показало, что DJB2 обеспечивает наилучшее распределение с минимальным количеством коллизий, за ней следует полиномиальная хеш-функция. Простая хеш-функция подвержена коллизиям для похожих ключей.

  6. Временная сложность подтверждена экспериментально: O(1) для операций в среднем случае при правильном выборе коэффициента заполнения и хеш-функции.

  ## Ответы на контрольные вопросы

  1. Какие методы разрешения коллизий наиболее эффективны и в каких случаях?
  - Метод цепочек: для приложений с переменной нагрузкой и высокими коэффициентами заполнения
  - Открытая адресация: когда важна эффективность использования памяти и предсказуемость доступа
  - Двойное хеширование: для минимизации кластеризации и улучшения распределения

  2. Как коэффициент заполнения влияет на производительность хеш-таблиц?
  - Метод цепочек: плавное снижение производительности до коэффициента 0.9
  - Открытая адресация: резкое снижение производительности после коэффициента 0.7
  - Критический порог: 0.7 для открытой адресации, 0.9 для метода цепочек

  3. В чем преимущество метода цепочек перед открытой адресацией?
  - Более устойчив к высоким коэффициентам заполнения
  - Проще в реализации и отладке
  - Не требует сложной логики пробирования
  - Легко удаляет элементы

  4. Когда следует использовать двойное хеширование вместо линейного пробирования?
  - При высоких требованиях к производительности
  - Когда ожидается высокий коэффициент заполнения
  - Для минимизации эффекта кластеризации
  - В системах, где важна предсказуемость времени доступа

  5. Как выбрать хорошую хеш-функцию для строковых ключей?
  - DJB2: обеспечивает хорошее распределение и быстрое вычисление
  - Полиномиальная: хороший баланс между скоростью и качеством распределения
  - Критерии выбора: равномерность распределения, скорость вычисления, минимальность коллизий

## Приложения
Исходный код: hash_functions.py, hash_table_chaining.py, hash_table_open_addressing.py, test_hash_tables.py, performance_analysis.py
График сравнения: performance_results.png

![Search Comparison](performance_results.png)


